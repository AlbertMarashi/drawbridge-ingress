//! # Drawbridge-Ingress
//!
//! A load balancer written in rust made for routing traffic to kubernetes services.
//!
//! ## How it works
//! 1. A task which regularly queries the kubernetes api for the list of services, ingresses, and listens for changes.
//! 2. letsencrypt is used to generate certificates for the hosts configured in the ingress.
//! 3. Constructs a routing rable based on the loaded kubernetes ingress configurations.
//! 4. listen on :80 and :443 for incoming http and https requests. The requests are routed to the appropriate service
//! according to the routing table, and a reverse proxy is used to forward the request to the service.
//! 5. incoming https requests are matched against the appropriate SSL certificate generated by letsencrypt.
//!
#![feature(never_type)]
#![feature(try_blocks)]
use certificate_generation::LetsEncrypt;
use hyper::server::conn::AddrIncoming;
use hyper::service::{make_service_fn, service_fn};
use hyper::Server;
use kube_config_tracker::{ChangeType, RoutingTable};
use proxy::proxy_request;
use std::ffi::OsString;
use std::net::SocketAddr;
use std::sync::Arc;
use tls_acceptor::tls_acceptor::TlsAcceptor;

use crate::error::{Code, IngressLoadBalancerError};

mod certificate_generation;
mod error;
mod kube_config_tracker;
mod leadership_system;
mod proxy;

type Error = Box<dyn std::error::Error + Send + Sync + 'static>;

fn get_current_pod_name() -> String {
    std::env::var_os("CURRENT_POD_IP")
        .unwrap()
        .to_string_lossy()
        .to_string()
}

#[tokio::main]
async fn main() {
    let routing_table = Arc::new(RoutingTable::new());
    let certificate_generation = Arc::new(LetsEncrypt::setup(routing_table.clone()).await);
    let leadership_system = leadership_system::LeadershipSystem::new(
        get_current_pod_name(),
        certificate_generation.clone(),
        routing_table.clone(),
    );

    let certificate_generation_clone = certificate_generation.clone();

    // watch for changes to the backends and peers.
    // if we are the leader, we will generate new certificates.
    // if we are not the leader, we will just ignore
    // if there are new peers, we will let the senator know
    // if peers were removed we will let the senator know
    routing_table
        .subscribe(Box::new(move |change_type| match change_type {
            ChangeType::BackendChanged => {
                let certificate_generation = certificate_generation_clone.clone();
                tokio::task::spawn(async move {
                    certificate_generation.check_for_new_certificates().await;
                });
            }
            _ => {}
        }))
        .await;

    // start a task which listens for changes to the kubernetes api
    // and updates the routing table accordingly
    tokio::spawn(routing_table.clone().start_watching());

    let proxy_service_handler = Arc::new(|| {
        let routing_table = routing_table.clone();
        let certificate_generation = certificate_generation.clone();
        async move {
            Ok::<_, Error>(service_fn(move |req| {
                proxy_request(routing_table.clone(), req, certificate_generation.clone())
            }))
        }
    });

    let proxy_service_http = make_service_fn(|_| proxy_service_handler.clone()());
    let proxy_service_https = make_service_fn(|_| proxy_service_handler.clone()());

    let https_incoming = AddrIncoming::bind(&SocketAddr::from(([0, 0, 0, 0], 443))).unwrap();
    let incoming_tls_acceptor = TlsAcceptor::new(https_incoming, certificate_generation.clone());
    let http_server = Server::bind(&SocketAddr::from(([0, 0, 0, 0], 80))).serve(proxy_service_http);
    let https_server = Server::builder(incoming_tls_acceptor).serve(proxy_service_https);

    let (_, _) = futures::future::join(http_server, https_server).await;
}
